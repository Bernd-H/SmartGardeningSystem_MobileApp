<?xml version="1.0"?>
<doc>
    <assembly>
        <name>MobileApp.Common</name>
    </assembly>
    <members>
        <member name="M:TinyIoC.TypeExtensions.GetGenericMethod(System.Type,System.Reflection.BindingFlags,System.String,System.Type[],System.Type[])">
            <summary>
            Gets a generic method from a type given the method name, binding flags, generic types and parameter types
            </summary>
            <param name="sourceType">Source type</param>
            <param name="bindingFlags">Binding flags</param>
            <param name="methodName">Name of the method</param>
            <param name="genericTypes">Generic types to use to make the method generic</param>
            <param name="parameterTypes">Method parameters</param>
            <returns>MethodInfo or null if no matches found</returns>
            <exception cref="T:System.Reflection.AmbiguousMatchException"/>
            <exception cref="T:System.ArgumentException"/>
        </member>
        <member name="T:TinyIoC.NamedParameterOverloads">
            <summary>
            Name/Value pairs for specifying "user" parameters when resolving
            </summary>
        </member>
        <member name="F:TinyIoC.UnregisteredResolutionActions.AttemptResolve">
            <summary>
            Attempt to resolve type, even if the type isn't registered.
            
            Registered types/options will always take precedence.
            </summary>
        </member>
        <member name="F:TinyIoC.UnregisteredResolutionActions.Fail">
            <summary>
            Fail resolution if type not explicitly registered
            </summary>
        </member>
        <member name="F:TinyIoC.UnregisteredResolutionActions.GenericsOnly">
            <summary>
            Attempt to resolve unregistered type if requested type is generic
            and no registration exists for the specific generic parameters used.
            
            Registered types/options will always take precedence.
            </summary>
        </member>
        <member name="T:TinyIoC.ResolveOptions">
            <summary>
            Resolution settings
            </summary>
        </member>
        <member name="P:TinyIoC.ResolveOptions.Default">
            <summary>
            Gets the default options (attempt resolution of unregistered types, fail on named resolution if name not found)
            </summary>
        </member>
        <member name="P:TinyIoC.ResolveOptions.FailNameNotFoundOnly">
            <summary>
            Preconfigured option for attempting resolution of unregistered types and failing on named resolution if name not found
            </summary>
        </member>
        <member name="P:TinyIoC.ResolveOptions.FailUnregisteredAndNameNotFound">
            <summary>
            Preconfigured option for failing on resolving unregistered types and on named resolution if name not found
            </summary>
        </member>
        <member name="P:TinyIoC.ResolveOptions.FailUnregisteredOnly">
            <summary>
            Preconfigured option for failing on resolving unregistered types, but attempting unnamed resolution if name not found
            </summary>
        </member>
        <member name="T:TinyIoC.TinyIoCContainer.RegisterOptions">
            <summary>
            Registration options for "fluent" API
            </summary>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.RegisterOptions.AsSingleton">
            <summary>
            Make registration a singleton (single instance) if possible
            </summary>
            <returns>RegisterOptions</returns>
            <exception cref="T:TinyIoC.TinyIoCRegistrationException"></exception>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.RegisterOptions.AsMultiInstance">
            <summary>
            Make registration multi-instance if possible
            </summary>
            <returns>RegisterOptions</returns>
            <exception cref="T:TinyIoC.TinyIoCRegistrationException"></exception>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.RegisterOptions.WithWeakReference">
            <summary>
            Make registration hold a weak reference if possible
            </summary>
            <returns>RegisterOptions</returns>
            <exception cref="T:TinyIoC.TinyIoCRegistrationException"></exception>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.RegisterOptions.WithStrongReference">
            <summary>
            Make registration hold a strong reference if possible
            </summary>
            <returns>RegisterOptions</returns>
            <exception cref="T:TinyIoC.TinyIoCRegistrationException"></exception>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.RegisterOptions.ToCustomLifetimeManager(TinyIoC.TinyIoCContainer.RegisterOptions,TinyIoC.TinyIoCContainer.ITinyIoCObjectLifetimeProvider,System.String)">
            <summary>
            Switches to a custom lifetime manager factory if possible.
            
            Usually used for RegisterOptions "To*" extension methods such as the ASP.Net per-request one.
            </summary>
            <param name="instance">RegisterOptions instance</param>
            <param name="lifetimeProvider">Custom lifetime manager</param>
            <param name="errorString">Error string to display if switch fails</param>
            <returns>RegisterOptions</returns>
        </member>
        <member name="T:TinyIoC.TinyIoCContainer.MultiRegisterOptions">
            <summary>
            Registration options for "fluent" API when registering multiple implementations
            </summary>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.MultiRegisterOptions.#ctor(System.Collections.Generic.IEnumerable{TinyIoC.TinyIoCContainer.RegisterOptions})">
            <summary>
            Initializes a new instance of the MultiRegisterOptions class.
            </summary>
            <param name="registerOptions">Registration options</param>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.MultiRegisterOptions.AsSingleton">
            <summary>
            Make registration a singleton (single instance) if possible
            </summary>
            <returns>RegisterOptions</returns>
            <exception cref="T:TinyIoC.TinyIoCRegistrationException"></exception>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.MultiRegisterOptions.AsMultiInstance">
            <summary>
            Make registration multi-instance if possible
            </summary>
            <returns>MultiRegisterOptions</returns>
            <exception cref="T:TinyIoC.TinyIoCRegistrationException"></exception>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.MultiRegisterOptions.ToCustomLifetimeManager(TinyIoC.TinyIoCContainer.MultiRegisterOptions,TinyIoC.TinyIoCContainer.ITinyIoCObjectLifetimeProvider,System.String)">
            <summary>
            Switches to a custom lifetime manager factory if possible.
            
            Usually used for RegisterOptions "To*" extension methods such as the ASP.Net per-request one.
            </summary>
            <param name="instance">MultiRegisterOptions instance</param>
            <param name="lifetimeProvider">Custom lifetime manager</param>
            <param name="errorString">Error string to display if switch fails</param>
            <returns>MultiRegisterOptions</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.AutoRegister">
            <summary>
            Attempt to automatically register all non-generic classes and interfaces in the current app domain.
            
            If more than one class implements an interface then only one implementation will be registered
            although no error will be thrown.
            </summary>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.AutoRegister(System.Func{System.Type,System.Boolean})">
            <summary>
            Attempt to automatically register all non-generic classes and interfaces in the current app domain.
            Types will only be registered if they pass the supplied registration predicate.
            
            If more than one class implements an interface then only one implementation will be registered
            although no error will be thrown.
            </summary>
            <param name="registrationPredicate">Predicate to determine if a particular type should be registered</param>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.AutoRegister(TinyIoC.DuplicateImplementationActions)">
            <summary>
            Attempt to automatically register all non-generic classes and interfaces in the current app domain.
            </summary>
            <param name="duplicateAction">What action to take when encountering duplicate implementations of an interface/base class.</param>
            <exception cref="T:TinyIoC.TinyIoCAutoRegistrationException"/>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.AutoRegister(TinyIoC.DuplicateImplementationActions,System.Func{System.Type,System.Boolean})">
            <summary>
            Attempt to automatically register all non-generic classes and interfaces in the current app domain.
            Types will only be registered if they pass the supplied registration predicate.
            </summary>
            <param name="duplicateAction">What action to take when encountering duplicate implementations of an interface/base class.</param>
            <param name="registrationPredicate">Predicate to determine if a particular type should be registered</param>
            <exception cref="T:TinyIoC.TinyIoCAutoRegistrationException"/>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.AutoRegister(System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
            <summary>
            Attempt to automatically register all non-generic classes and interfaces in the specified assemblies
            
            If more than one class implements an interface then only one implementation will be registered
            although no error will be thrown.
            </summary>
            <param name="assemblies">Assemblies to process</param>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.AutoRegister(System.Collections.Generic.IEnumerable{System.Reflection.Assembly},System.Func{System.Type,System.Boolean})">
            <summary>
            Attempt to automatically register all non-generic classes and interfaces in the specified assemblies
            Types will only be registered if they pass the supplied registration predicate.
            
            If more than one class implements an interface then only one implementation will be registered
            although no error will be thrown.
            </summary>
            <param name="assemblies">Assemblies to process</param>
            <param name="registrationPredicate">Predicate to determine if a particular type should be registered</param>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.AutoRegister(System.Collections.Generic.IEnumerable{System.Reflection.Assembly},TinyIoC.DuplicateImplementationActions)">
            <summary>
            Attempt to automatically register all non-generic classes and interfaces in the specified assemblies
            </summary>
            <param name="assemblies">Assemblies to process</param>
            <param name="duplicateAction">What action to take when encountering duplicate implementations of an interface/base class.</param>
            <exception cref="T:TinyIoC.TinyIoCAutoRegistrationException"/>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.AutoRegister(System.Collections.Generic.IEnumerable{System.Reflection.Assembly},TinyIoC.DuplicateImplementationActions,System.Func{System.Type,System.Boolean})">
            <summary>
            Attempt to automatically register all non-generic classes and interfaces in the specified assemblies
            Types will only be registered if they pass the supplied registration predicate.
            </summary>
            <param name="assemblies">Assemblies to process</param>
            <param name="duplicateAction">What action to take when encountering duplicate implementations of an interface/base class.</param>
            <param name="registrationPredicate">Predicate to determine if a particular type should be registered</param>
            <exception cref="T:TinyIoC.TinyIoCAutoRegistrationException"/>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.Register(System.Type)">
            <summary>
            Creates/replaces a container class registration with default options.
            </summary>
            <param name="registerType">Type to register</param>
            <returns>RegisterOptions for fluent API</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.Register(System.Type,System.String)">
            <summary>
            Creates/replaces a named container class registration with default options.
            </summary>
            <param name="registerType">Type to register</param>
            <param name="name">Name of registration</param>
            <returns>RegisterOptions for fluent API</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.Register(System.Type,System.Type)">
            <summary>
            Creates/replaces a container class registration with a given implementation and default options.
            </summary>
            <param name="registerType">Type to register</param>
            <param name="registerImplementation">Type to instantiate that implements RegisterType</param>
            <returns>RegisterOptions for fluent API</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.Register(System.Type,System.Type,System.String)">
            <summary>
            Creates/replaces a named container class registration with a given implementation and default options.
            </summary>
            <param name="registerType">Type to register</param>
            <param name="registerImplementation">Type to instantiate that implements RegisterType</param>
            <param name="name">Name of registration</param>
            <returns>RegisterOptions for fluent API</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.Register(System.Type,System.Object)">
            <summary>
            Creates/replaces a container class registration with a specific, strong referenced, instance.
            </summary>
            <param name="registerType">Type to register</param>
            <param name="instance">Instance of RegisterType to register</param>
            <returns>RegisterOptions for fluent API</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.Register(System.Type,System.Object,System.String)">
            <summary>
            Creates/replaces a named container class registration with a specific, strong referenced, instance.
            </summary>
            <param name="registerType">Type to register</param>
            <param name="instance">Instance of RegisterType to register</param>
            <param name="name">Name of registration</param>
            <returns>RegisterOptions for fluent API</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.Register(System.Type,System.Type,System.Object)">
            <summary>
            Creates/replaces a container class registration with a specific, strong referenced, instance.
            </summary>
            <param name="registerType">Type to register</param>
            <param name="registerImplementation">Type of instance to register that implements RegisterType</param>
            <param name="instance">Instance of RegisterImplementation to register</param>
            <returns>RegisterOptions for fluent API</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.Register(System.Type,System.Type,System.Object,System.String)">
            <summary>
            Creates/replaces a named container class registration with a specific, strong referenced, instance.
            </summary>
            <param name="registerType">Type to register</param>
            <param name="registerImplementation">Type of instance to register that implements RegisterType</param>
            <param name="instance">Instance of RegisterImplementation to register</param>
            <param name="name">Name of registration</param>
            <returns>RegisterOptions for fluent API</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.Register(System.Type,System.Func{TinyIoC.TinyIoCContainer,TinyIoC.NamedParameterOverloads,System.Object})">
            <summary>
            Creates/replaces a container class registration with a user specified factory
            </summary>
            <param name="registerType">Type to register</param>
            <param name="factory">Factory/lambda that returns an instance of RegisterType</param>
            <returns>RegisterOptions for fluent API</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.Register(System.Type,System.Func{TinyIoC.TinyIoCContainer,TinyIoC.NamedParameterOverloads,System.Object},System.String)">
            <summary>
            Creates/replaces a container class registration with a user specified factory
            </summary>
            <param name="registerType">Type to register</param>
            <param name="factory">Factory/lambda that returns an instance of RegisterType</param>
            <param name="name">Name of registration</param>
            <returns>RegisterOptions for fluent API</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.Register``1">
            <summary>
            Creates/replaces a container class registration with default options.
            </summary>
            <typeparam name="RegisterType">Type to register</typeparam>
            <returns>RegisterOptions for fluent API</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.Register``1(System.String)">
            <summary>
            Creates/replaces a named container class registration with default options.
            </summary>
            <typeparam name="RegisterType">Type to register</typeparam>
            <param name="name">Name of registration</param>
            <returns>RegisterOptions for fluent API</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.Register``2">
            <summary>
            Creates/replaces a container class registration with a given implementation and default options.
            </summary>
            <typeparam name="RegisterType">Type to register</typeparam>
            <typeparam name="RegisterImplementation">Type to instantiate that implements RegisterType</typeparam>
            <returns>RegisterOptions for fluent API</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.Register``2(System.String)">
            <summary>
            Creates/replaces a named container class registration with a given implementation and default options.
            </summary>
            <typeparam name="RegisterType">Type to register</typeparam>
            <typeparam name="RegisterImplementation">Type to instantiate that implements RegisterType</typeparam>
            <param name="name">Name of registration</param>
            <returns>RegisterOptions for fluent API</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.Register``1(``0)">
            <summary>
            Creates/replaces a container class registration with a specific, strong referenced, instance.
            </summary>
            <typeparam name="RegisterType">Type to register</typeparam>
            <param name="instance">Instance of RegisterType to register</param>
            <returns>RegisterOptions for fluent API</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.Register``1(``0,System.String)">
            <summary>
            Creates/replaces a named container class registration with a specific, strong referenced, instance.
            </summary>
            <typeparam name="RegisterType">Type to register</typeparam>
            <param name="instance">Instance of RegisterType to register</param>
            <param name="name">Name of registration</param>
            <returns>RegisterOptions for fluent API</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.Register``2(``1)">
            <summary>
            Creates/replaces a container class registration with a specific, strong referenced, instance.
            </summary>
            <typeparam name="RegisterType">Type to register</typeparam>
            <typeparam name="RegisterImplementation">Type of instance to register that implements RegisterType</typeparam>
            <param name="instance">Instance of RegisterImplementation to register</param>
            <returns>RegisterOptions for fluent API</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.Register``2(``1,System.String)">
            <summary>
            Creates/replaces a named container class registration with a specific, strong referenced, instance.
            </summary>
            <typeparam name="RegisterType">Type to register</typeparam>
            <typeparam name="RegisterImplementation">Type of instance to register that implements RegisterType</typeparam>
            <param name="instance">Instance of RegisterImplementation to register</param>
            <param name="name">Name of registration</param>
            <returns>RegisterOptions for fluent API</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.Register``1(System.Func{TinyIoC.TinyIoCContainer,TinyIoC.NamedParameterOverloads,``0})">
            <summary>
            Creates/replaces a container class registration with a user specified factory
            </summary>
            <typeparam name="RegisterType">Type to register</typeparam>
            <param name="factory">Factory/lambda that returns an instance of RegisterType</param>
            <returns>RegisterOptions for fluent API</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.Register``1(System.Func{TinyIoC.TinyIoCContainer,TinyIoC.NamedParameterOverloads,``0},System.String)">
            <summary>
            Creates/replaces a named container class registration with a user specified factory
            </summary>
            <typeparam name="RegisterType">Type to register</typeparam>
            <param name="factory">Factory/lambda that returns an instance of RegisterType</param>
            <param name="name">Name of registration</param>
            <returns>RegisterOptions for fluent API</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.RegisterMultiple``1(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Register multiple implementations of a type.
            
            Internally this registers each implementation using the full name of the class as its registration name.
            </summary>
            <typeparam name="RegisterType">Type that each implementation implements</typeparam>
            <param name="implementationTypes">Types that implement RegisterType</param>
            <returns>MultiRegisterOptions for the fluent API</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.RegisterMultiple(System.Type,System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Register multiple implementations of a type.
            
            Internally this registers each implementation using the full name of the class as its registration name.
            </summary>
            <param name="registrationType">Type that each implementation implements</param>
            <param name="implementationTypes">Types that implement RegisterType</param>
            <returns>MultiRegisterOptions for the fluent API</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.Unregister``1">
            <summary>
            Remove a container class registration.
            </summary>
            <typeparam name="RegisterType">Type to unregister</typeparam>
            <returns>true if the registration is successfully found and removed; otherwise, false.</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.Unregister``1(System.String)">
            <summary>
            Remove a named container class registration.
            </summary>
            <typeparam name="RegisterType">Type to unregister</typeparam>
            <param name="name">Name of registration</param>
            <returns>true if the registration is successfully found and removed; otherwise, false.</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.Unregister(System.Type)">
            <summary>
            Remove a container class registration.
            </summary>
            <param name="registerType">Type to unregister</param>
            <returns>true if the registration is successfully found and removed; otherwise, false.</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.Unregister(System.Type,System.String)">
            <summary>
            Remove a named container class registration.
            </summary>
            <param name="registerType">Type to unregister</param>
            <param name="name">Name of registration</param>
            <returns>true if the registration is successfully found and removed; otherwise, false.</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.Resolve(System.Type)">
            <summary>
            Attempts to resolve a type using default options.
            </summary>
            <param name="resolveType">Type to resolve</param>
            <returns>Instance of type</returns>
            <exception cref="T:TinyIoC.TinyIoCResolutionException">Unable to resolve the type.</exception>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.Resolve(System.Type,TinyIoC.ResolveOptions)">
            <summary>
            Attempts to resolve a type using specified options.
            </summary>
            <param name="resolveType">Type to resolve</param>
            <param name="options">Resolution options</param>
            <returns>Instance of type</returns>
            <exception cref="T:TinyIoC.TinyIoCResolutionException">Unable to resolve the type.</exception>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.Resolve(System.Type,System.String)">
             <summary>
             Attempts to resolve a type using default options and the supplied name.
            
             Parameters are used in conjunction with normal container resolution to find the most suitable constructor (if one exists).
             All user supplied parameters must exist in at least one resolvable constructor of RegisterType or resolution will fail.
             </summary>
             <param name="resolveType">Type to resolve</param>
             <param name="name">Name of registration</param>
             <returns>Instance of type</returns>
             <exception cref="T:TinyIoC.TinyIoCResolutionException">Unable to resolve the type.</exception>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.Resolve(System.Type,System.String,TinyIoC.ResolveOptions)">
             <summary>
             Attempts to resolve a type using supplied options and  name.
            
             Parameters are used in conjunction with normal container resolution to find the most suitable constructor (if one exists).
             All user supplied parameters must exist in at least one resolvable constructor of RegisterType or resolution will fail.
             </summary>
             <param name="resolveType">Type to resolve</param>
             <param name="name">Name of registration</param>
             <param name="options">Resolution options</param>
             <returns>Instance of type</returns>
             <exception cref="T:TinyIoC.TinyIoCResolutionException">Unable to resolve the type.</exception>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.Resolve(System.Type,TinyIoC.NamedParameterOverloads)">
             <summary>
             Attempts to resolve a type using default options and the supplied constructor parameters.
            
             Parameters are used in conjunction with normal container resolution to find the most suitable constructor (if one exists).
             All user supplied parameters must exist in at least one resolvable constructor of RegisterType or resolution will fail.
             </summary>
             <param name="resolveType">Type to resolve</param>
             <param name="parameters">User specified constructor parameters</param>
             <returns>Instance of type</returns>
             <exception cref="T:TinyIoC.TinyIoCResolutionException">Unable to resolve the type.</exception>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.Resolve(System.Type,TinyIoC.NamedParameterOverloads,TinyIoC.ResolveOptions)">
             <summary>
             Attempts to resolve a type using specified options and the supplied constructor parameters.
            
             Parameters are used in conjunction with normal container resolution to find the most suitable constructor (if one exists).
             All user supplied parameters must exist in at least one resolvable constructor of RegisterType or resolution will fail.
             </summary>
             <param name="resolveType">Type to resolve</param>
             <param name="parameters">User specified constructor parameters</param>
             <param name="options">Resolution options</param>
             <returns>Instance of type</returns>
             <exception cref="T:TinyIoC.TinyIoCResolutionException">Unable to resolve the type.</exception>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.Resolve(System.Type,System.String,TinyIoC.NamedParameterOverloads)">
             <summary>
             Attempts to resolve a type using default options and the supplied constructor parameters and name.
            
             Parameters are used in conjunction with normal container resolution to find the most suitable constructor (if one exists).
             All user supplied parameters must exist in at least one resolvable constructor of RegisterType or resolution will fail.
             </summary>
             <param name="resolveType">Type to resolve</param>
             <param name="parameters">User specified constructor parameters</param>
             <param name="name">Name of registration</param>
             <returns>Instance of type</returns>
             <exception cref="T:TinyIoC.TinyIoCResolutionException">Unable to resolve the type.</exception>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.Resolve(System.Type,System.String,TinyIoC.NamedParameterOverloads,TinyIoC.ResolveOptions)">
             <summary>
             Attempts to resolve a named type using specified options and the supplied constructor parameters.
            
             Parameters are used in conjunction with normal container resolution to find the most suitable constructor (if one exists).
             All user supplied parameters must exist in at least one resolvable constructor of RegisterType or resolution will fail.
             </summary>
             <param name="resolveType">Type to resolve</param>
             <param name="name">Name of registration</param>
             <param name="parameters">User specified constructor parameters</param>
             <param name="options">Resolution options</param>
             <returns>Instance of type</returns>
             <exception cref="T:TinyIoC.TinyIoCResolutionException">Unable to resolve the type.</exception>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.Resolve``1">
            <summary>
            Attempts to resolve a type using default options.
            </summary>
            <typeparam name="ResolveType">Type to resolve</typeparam>
            <returns>Instance of type</returns>
            <exception cref="T:TinyIoC.TinyIoCResolutionException">Unable to resolve the type.</exception>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.Resolve``1(TinyIoC.ResolveOptions)">
            <summary>
            Attempts to resolve a type using specified options.
            </summary>
            <typeparam name="ResolveType">Type to resolve</typeparam>
            <param name="options">Resolution options</param>
            <returns>Instance of type</returns>
            <exception cref="T:TinyIoC.TinyIoCResolutionException">Unable to resolve the type.</exception>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.Resolve``1(System.String)">
             <summary>
             Attempts to resolve a type using default options and the supplied name.
            
             Parameters are used in conjunction with normal container resolution to find the most suitable constructor (if one exists).
             All user supplied parameters must exist in at least one resolvable constructor of RegisterType or resolution will fail.
             </summary>
             <typeparam name="ResolveType">Type to resolve</typeparam>
             <param name="name">Name of registration</param>
             <returns>Instance of type</returns>
             <exception cref="T:TinyIoC.TinyIoCResolutionException">Unable to resolve the type.</exception>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.Resolve``1(System.String,TinyIoC.ResolveOptions)">
             <summary>
             Attempts to resolve a type using supplied options and  name.
            
             Parameters are used in conjunction with normal container resolution to find the most suitable constructor (if one exists).
             All user supplied parameters must exist in at least one resolvable constructor of RegisterType or resolution will fail.
             </summary>
             <typeparam name="ResolveType">Type to resolve</typeparam>
             <param name="name">Name of registration</param>
             <param name="options">Resolution options</param>
             <returns>Instance of type</returns>
             <exception cref="T:TinyIoC.TinyIoCResolutionException">Unable to resolve the type.</exception>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.Resolve``1(TinyIoC.NamedParameterOverloads)">
             <summary>
             Attempts to resolve a type using default options and the supplied constructor parameters.
            
             Parameters are used in conjunction with normal container resolution to find the most suitable constructor (if one exists).
             All user supplied parameters must exist in at least one resolvable constructor of RegisterType or resolution will fail.
             </summary>
             <typeparam name="ResolveType">Type to resolve</typeparam>
             <param name="parameters">User specified constructor parameters</param>
             <returns>Instance of type</returns>
             <exception cref="T:TinyIoC.TinyIoCResolutionException">Unable to resolve the type.</exception>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.Resolve``1(TinyIoC.NamedParameterOverloads,TinyIoC.ResolveOptions)">
             <summary>
             Attempts to resolve a type using specified options and the supplied constructor parameters.
            
             Parameters are used in conjunction with normal container resolution to find the most suitable constructor (if one exists).
             All user supplied parameters must exist in at least one resolvable constructor of RegisterType or resolution will fail.
             </summary>
             <typeparam name="ResolveType">Type to resolve</typeparam>
             <param name="parameters">User specified constructor parameters</param>
             <param name="options">Resolution options</param>
             <returns>Instance of type</returns>
             <exception cref="T:TinyIoC.TinyIoCResolutionException">Unable to resolve the type.</exception>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.Resolve``1(System.String,TinyIoC.NamedParameterOverloads)">
             <summary>
             Attempts to resolve a type using default options and the supplied constructor parameters and name.
            
             Parameters are used in conjunction with normal container resolution to find the most suitable constructor (if one exists).
             All user supplied parameters must exist in at least one resolvable constructor of RegisterType or resolution will fail.
             </summary>
             <typeparam name="ResolveType">Type to resolve</typeparam>
             <param name="parameters">User specified constructor parameters</param>
             <param name="name">Name of registration</param>
             <returns>Instance of type</returns>
             <exception cref="T:TinyIoC.TinyIoCResolutionException">Unable to resolve the type.</exception>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.Resolve``1(System.String,TinyIoC.NamedParameterOverloads,TinyIoC.ResolveOptions)">
             <summary>
             Attempts to resolve a named type using specified options and the supplied constructor parameters.
            
             Parameters are used in conjunction with normal container resolution to find the most suitable constructor (if one exists).
             All user supplied parameters must exist in at least one resolvable constructor of RegisterType or resolution will fail.
             </summary>
             <typeparam name="ResolveType">Type to resolve</typeparam>
             <param name="name">Name of registration</param>
             <param name="parameters">User specified constructor parameters</param>
             <param name="options">Resolution options</param>
             <returns>Instance of type</returns>
             <exception cref="T:TinyIoC.TinyIoCResolutionException">Unable to resolve the type.</exception>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.CanResolve(System.Type)">
             <summary>
             Attempts to predict whether a given type can be resolved with default options.
            
             Note: Resolution may still fail if user defined factory registrations fail to construct objects when called.
             </summary>
             <param name="resolveType">Type to resolve</param>
             <returns>Bool indicating whether the type can be resolved</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.CanResolve(System.Type,System.String)">
             <summary>
             Attempts to predict whether a given named type can be resolved with default options.
            
             Note: Resolution may still fail if user defined factory registrations fail to construct objects when called.
             </summary>
             <param name="resolveType">Type to resolve</param>
             <param name="name">Name of registration</param>
             <returns>Bool indicating whether the type can be resolved</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.CanResolve(System.Type,TinyIoC.ResolveOptions)">
             <summary>
             Attempts to predict whether a given type can be resolved with the specified options.
            
             Note: Resolution may still fail if user defined factory registrations fail to construct objects when called.
             </summary>
             <param name="resolveType">Type to resolve</param>
             <param name="options">Resolution options</param>
             <returns>Bool indicating whether the type can be resolved</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.CanResolve(System.Type,System.String,TinyIoC.ResolveOptions)">
             <summary>
             Attempts to predict whether a given named type can be resolved with the specified options.
            
             Note: Resolution may still fail if user defined factory registrations fail to construct objects when called.
             </summary>
             <param name="resolveType">Type to resolve</param>
             <param name="name">Name of registration</param>
             <param name="options">Resolution options</param>
             <returns>Bool indicating whether the type can be resolved</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.CanResolve(System.Type,TinyIoC.NamedParameterOverloads)">
             <summary>
             Attempts to predict whether a given type can be resolved with the supplied constructor parameters and default options.
            
             Parameters are used in conjunction with normal container resolution to find the most suitable constructor (if one exists).
             All user supplied parameters must exist in at least one resolvable constructor of RegisterType or resolution will fail.
             
             Note: Resolution may still fail if user defined factory registrations fail to construct objects when called.
             </summary>
             <param name="resolveType">Type to resolve</param>
             <param name="parameters">User supplied named parameter overloads</param>
             <returns>Bool indicating whether the type can be resolved</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.CanResolve(System.Type,System.String,TinyIoC.NamedParameterOverloads)">
             <summary>
             Attempts to predict whether a given named type can be resolved with the supplied constructor parameters and default options.
            
             Parameters are used in conjunction with normal container resolution to find the most suitable constructor (if one exists).
             All user supplied parameters must exist in at least one resolvable constructor of RegisterType or resolution will fail.
             
             Note: Resolution may still fail if user defined factory registrations fail to construct objects when called.
             </summary>
             <param name="resolveType">Type to resolve</param>
             <param name="name">Name of registration</param>
             <param name="parameters">User supplied named parameter overloads</param>
             <returns>Bool indicating whether the type can be resolved</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.CanResolve(System.Type,TinyIoC.NamedParameterOverloads,TinyIoC.ResolveOptions)">
             <summary>
             Attempts to predict whether a given type can be resolved with the supplied constructor parameters options.
            
             Parameters are used in conjunction with normal container resolution to find the most suitable constructor (if one exists).
             All user supplied parameters must exist in at least one resolvable constructor of RegisterType or resolution will fail.
             
             Note: Resolution may still fail if user defined factory registrations fail to construct objects when called.
             </summary>
             <param name="resolveType">Type to resolve</param>
             <param name="parameters">User supplied named parameter overloads</param>
             <param name="options">Resolution options</param>
             <returns>Bool indicating whether the type can be resolved</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.CanResolve(System.Type,System.String,TinyIoC.NamedParameterOverloads,TinyIoC.ResolveOptions)">
             <summary>
             Attempts to predict whether a given named type can be resolved with the supplied constructor parameters options.
            
             Parameters are used in conjunction with normal container resolution to find the most suitable constructor (if one exists).
             All user supplied parameters must exist in at least one resolvable constructor of RegisterType or resolution will fail.
             
             Note: Resolution may still fail if user defined factory registrations fail to construct objects when called.
             </summary>
             <param name="resolveType">Type to resolve</param>
             <param name="name">Name of registration</param>
             <param name="parameters">User supplied named parameter overloads</param>
             <param name="options">Resolution options</param>
             <returns>Bool indicating whether the type can be resolved</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.CanResolve``1">
             <summary>
             Attempts to predict whether a given type can be resolved with default options.
            
             Note: Resolution may still fail if user defined factory registrations fail to construct objects when called.
             </summary>
             <typeparam name="ResolveType">Type to resolve</typeparam>
             <returns>Bool indicating whether the type can be resolved</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.CanResolve``1(System.String)">
             <summary>
             Attempts to predict whether a given named type can be resolved with default options.
            
             Note: Resolution may still fail if user defined factory registrations fail to construct objects when called.
             </summary>
             <typeparam name="ResolveType">Type to resolve</typeparam>
             <returns>Bool indicating whether the type can be resolved</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.CanResolve``1(TinyIoC.ResolveOptions)">
             <summary>
             Attempts to predict whether a given type can be resolved with the specified options.
            
             Note: Resolution may still fail if user defined factory registrations fail to construct objects when called.
             </summary>
             <typeparam name="ResolveType">Type to resolve</typeparam>
             <param name="options">Resolution options</param>
             <returns>Bool indicating whether the type can be resolved</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.CanResolve``1(System.String,TinyIoC.ResolveOptions)">
             <summary>
             Attempts to predict whether a given named type can be resolved with the specified options.
            
             Note: Resolution may still fail if user defined factory registrations fail to construct objects when called.
             </summary>
             <typeparam name="ResolveType">Type to resolve</typeparam>
             <param name="name">Name of registration</param>
             <param name="options">Resolution options</param>
             <returns>Bool indicating whether the type can be resolved</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.CanResolve``1(TinyIoC.NamedParameterOverloads)">
             <summary>
             Attempts to predict whether a given type can be resolved with the supplied constructor parameters and default options.
            
             Parameters are used in conjunction with normal container resolution to find the most suitable constructor (if one exists).
             All user supplied parameters must exist in at least one resolvable constructor of RegisterType or resolution will fail.
             
             Note: Resolution may still fail if user defined factory registrations fail to construct objects when called.
             </summary>
             <typeparam name="ResolveType">Type to resolve</typeparam>
             <param name="parameters">User supplied named parameter overloads</param>
             <returns>Bool indicating whether the type can be resolved</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.CanResolve``1(System.String,TinyIoC.NamedParameterOverloads)">
             <summary>
             Attempts to predict whether a given named type can be resolved with the supplied constructor parameters and default options.
            
             Parameters are used in conjunction with normal container resolution to find the most suitable constructor (if one exists).
             All user supplied parameters must exist in at least one resolvable constructor of RegisterType or resolution will fail.
             
             Note: Resolution may still fail if user defined factory registrations fail to construct objects when called.
             </summary>
             <typeparam name="ResolveType">Type to resolve</typeparam>
             <param name="name">Name of registration</param>
             <param name="parameters">User supplied named parameter overloads</param>
             <returns>Bool indicating whether the type can be resolved</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.CanResolve``1(TinyIoC.NamedParameterOverloads,TinyIoC.ResolveOptions)">
             <summary>
             Attempts to predict whether a given type can be resolved with the supplied constructor parameters options.
            
             Parameters are used in conjunction with normal container resolution to find the most suitable constructor (if one exists).
             All user supplied parameters must exist in at least one resolvable constructor of RegisterType or resolution will fail.
             
             Note: Resolution may still fail if user defined factory registrations fail to construct objects when called.
             </summary>
             <typeparam name="ResolveType">Type to resolve</typeparam>
             <param name="parameters">User supplied named parameter overloads</param>
             <param name="options">Resolution options</param>
             <returns>Bool indicating whether the type can be resolved</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.CanResolve``1(System.String,TinyIoC.NamedParameterOverloads,TinyIoC.ResolveOptions)">
             <summary>
             Attempts to predict whether a given named type can be resolved with the supplied constructor parameters options.
            
             Parameters are used in conjunction with normal container resolution to find the most suitable constructor (if one exists).
             All user supplied parameters must exist in at least one resolvable constructor of RegisterType or resolution will fail.
             
             Note: Resolution may still fail if user defined factory registrations fail to construct objects when called.
             </summary>
             <typeparam name="ResolveType">Type to resolve</typeparam>
             <param name="name">Name of registration</param>
             <param name="parameters">User supplied named parameter overloads</param>
             <param name="options">Resolution options</param>
             <returns>Bool indicating whether the type can be resolved</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.TryResolve(System.Type,System.Object@)">
            <summary>
            Attempts to resolve a type using the default options
            </summary>
            <param name="resolveType">Type to resolve</param>
            <param name="resolvedType">Resolved type or default if resolve fails</param>
            <returns>True if resolved successfully, false otherwise</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.TryResolve(System.Type,TinyIoC.ResolveOptions,System.Object@)">
            <summary>
            Attempts to resolve a type using the given options
            </summary>
            <param name="resolveType">Type to resolve</param>
            <param name="options">Resolution options</param>
            <param name="resolvedType">Resolved type or default if resolve fails</param>
            <returns>True if resolved successfully, false otherwise</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.TryResolve(System.Type,System.String,System.Object@)">
            <summary>
            Attempts to resolve a type using the default options and given name
            </summary>
            <param name="resolveType">Type to resolve</param>
            <param name="name">Name of registration</param>
            <param name="resolvedType">Resolved type or default if resolve fails</param>
            <returns>True if resolved successfully, false otherwise</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.TryResolve(System.Type,System.String,TinyIoC.ResolveOptions,System.Object@)">
            <summary>
            Attempts to resolve a type using the given options and name
            </summary>
            <param name="resolveType">Type to resolve</param>
            <param name="name">Name of registration</param>
            <param name="options">Resolution options</param>
            <param name="resolvedType">Resolved type or default if resolve fails</param>
            <returns>True if resolved successfully, false otherwise</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.TryResolve(System.Type,TinyIoC.NamedParameterOverloads,System.Object@)">
            <summary>
            Attempts to resolve a type using the default options and supplied constructor parameters
            </summary>
            <param name="resolveType">Type to resolve</param>
            <param name="parameters">User specified constructor parameters</param>
            <param name="resolvedType">Resolved type or default if resolve fails</param>
            <returns>True if resolved successfully, false otherwise</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.TryResolve(System.Type,System.String,TinyIoC.NamedParameterOverloads,System.Object@)">
            <summary>
            Attempts to resolve a type using the default options and supplied name and constructor parameters
            </summary>
            <param name="resolveType">Type to resolve</param>
            <param name="name">Name of registration</param>
            <param name="parameters">User specified constructor parameters</param>
            <param name="resolvedType">Resolved type or default if resolve fails</param>
            <returns>True if resolved successfully, false otherwise</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.TryResolve(System.Type,TinyIoC.NamedParameterOverloads,TinyIoC.ResolveOptions,System.Object@)">
            <summary>
            Attempts to resolve a type using the supplied options and constructor parameters
            </summary>
            <param name="resolveType">Type to resolve</param>
            <param name="parameters">User specified constructor parameters</param>
            <param name="options">Resolution options</param>
            <param name="resolvedType">Resolved type or default if resolve fails</param>
            <returns>True if resolved successfully, false otherwise</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.TryResolve(System.Type,System.String,TinyIoC.NamedParameterOverloads,TinyIoC.ResolveOptions,System.Object@)">
            <summary>
            Attempts to resolve a type using the supplied name, options and constructor parameters
            </summary>
            <param name="resolveType">Type to resolve</param>
            <param name="name">Name of registration</param>
            <param name="parameters">User specified constructor parameters</param>
            <param name="options">Resolution options</param>
            <param name="resolvedType">Resolved type or default if resolve fails</param>
            <returns>True if resolved successfully, false otherwise</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.TryResolve``1(``0@)">
            <summary>
            Attempts to resolve a type using the default options
            </summary>
            <typeparam name="ResolveType">Type to resolve</typeparam>
            <param name="resolvedType">Resolved type or default if resolve fails</param>
            <returns>True if resolved successfully, false otherwise</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.TryResolve``1(TinyIoC.ResolveOptions,``0@)">
            <summary>
            Attempts to resolve a type using the given options
            </summary>
            <typeparam name="ResolveType">Type to resolve</typeparam>
            <param name="options">Resolution options</param>
            <param name="resolvedType">Resolved type or default if resolve fails</param>
            <returns>True if resolved successfully, false otherwise</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.TryResolve``1(System.String,``0@)">
            <summary>
            Attempts to resolve a type using the default options and given name
            </summary>
            <typeparam name="ResolveType">Type to resolve</typeparam>
            <param name="name">Name of registration</param>
            <param name="resolvedType">Resolved type or default if resolve fails</param>
            <returns>True if resolved successfully, false otherwise</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.TryResolve``1(System.String,TinyIoC.ResolveOptions,``0@)">
            <summary>
            Attempts to resolve a type using the given options and name
            </summary>
            <typeparam name="ResolveType">Type to resolve</typeparam>
            <param name="name">Name of registration</param>
            <param name="options">Resolution options</param>
            <param name="resolvedType">Resolved type or default if resolve fails</param>
            <returns>True if resolved successfully, false otherwise</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.TryResolve``1(TinyIoC.NamedParameterOverloads,``0@)">
            <summary>
            Attempts to resolve a type using the default options and supplied constructor parameters
            </summary>
            <typeparam name="ResolveType">Type to resolve</typeparam>
            <param name="parameters">User specified constructor parameters</param>
            <param name="resolvedType">Resolved type or default if resolve fails</param>
            <returns>True if resolved successfully, false otherwise</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.TryResolve``1(System.String,TinyIoC.NamedParameterOverloads,``0@)">
            <summary>
            Attempts to resolve a type using the default options and supplied name and constructor parameters
            </summary>
            <typeparam name="ResolveType">Type to resolve</typeparam>
            <param name="name">Name of registration</param>
            <param name="parameters">User specified constructor parameters</param>
            <param name="resolvedType">Resolved type or default if resolve fails</param>
            <returns>True if resolved successfully, false otherwise</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.TryResolve``1(TinyIoC.NamedParameterOverloads,TinyIoC.ResolveOptions,``0@)">
            <summary>
            Attempts to resolve a type using the supplied options and constructor parameters
            </summary>
            <typeparam name="ResolveType">Type to resolve</typeparam>
            <param name="parameters">User specified constructor parameters</param>
            <param name="options">Resolution options</param>
            <param name="resolvedType">Resolved type or default if resolve fails</param>
            <returns>True if resolved successfully, false otherwise</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.TryResolve``1(System.String,TinyIoC.NamedParameterOverloads,TinyIoC.ResolveOptions,``0@)">
            <summary>
            Attempts to resolve a type using the supplied name, options and constructor parameters
            </summary>
            <typeparam name="ResolveType">Type to resolve</typeparam>
            <param name="name">Name of registration</param>
            <param name="parameters">User specified constructor parameters</param>
            <param name="options">Resolution options</param>
            <param name="resolvedType">Resolved type or default if resolve fails</param>
            <returns>True if resolved successfully, false otherwise</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.ResolveAll(System.Type,System.Boolean)">
            <summary>
            Returns all registrations of a type
            </summary>
            <param name="resolveType">Type to resolveAll</param>
            <param name="includeUnnamed">Whether to include un-named (default) registrations</param>
            <returns>IEnumerable</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.ResolveAll(System.Type)">
            <summary>
            Returns all registrations of a type, both named and unnamed
            </summary>
            <param name="resolveType">Type to resolveAll</param>
            <returns>IEnumerable</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.ResolveAll``1(System.Boolean)">
            <summary>
            Returns all registrations of a type
            </summary>
            <typeparam name="ResolveType">Type to resolveAll</typeparam>
            <param name="includeUnnamed">Whether to include un-named (default) registrations</param>
            <returns>IEnumerable</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.ResolveAll``1">
            <summary>
            Returns all registrations of a type, both named and unnamed
            </summary>
            <typeparam name="ResolveType">Type to resolveAll</typeparam>
            <returns>IEnumerable</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.BuildUp(System.Object)">
            <summary>
            Attempts to resolve all public property dependencies on the given object.
            </summary>
            <param name="input">Object to "build up"</param>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.BuildUp(System.Object,TinyIoC.ResolveOptions)">
            <summary>
            Attempts to resolve all public property dependencies on the given object using the given resolve options.
            </summary>
            <param name="input">Object to "build up"</param>
            <param name="resolveOptions">Resolve options to use</param>
        </member>
        <member name="T:TinyIoC.TinyIoCContainer.ITinyIoCObjectLifetimeProvider">
            <summary>
            Provides custom lifetime management for ASP.Net per-request lifetimes etc.
            </summary>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.ITinyIoCObjectLifetimeProvider.GetObject">
            <summary>
            Gets the stored object if it exists, or null if not
            </summary>
            <returns>Object instance or null</returns>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.ITinyIoCObjectLifetimeProvider.SetObject(System.Object)">
            <summary>
            Store the object
            </summary>
            <param name="value">Object to store</param>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.ITinyIoCObjectLifetimeProvider.ReleaseObject">
            <summary>
            Release the object
            </summary>
        </member>
        <member name="P:TinyIoC.TinyIoCContainer.ObjectFactoryBase.AssumeConstruction">
            <summary>
            Whether to assume this factory successfully constructs its objects
            
            Generally set to true for delegate style factories as CanResolve cannot delve
            into the delegates they contain.
            </summary>
        </member>
        <member name="P:TinyIoC.TinyIoCContainer.ObjectFactoryBase.CreatesType">
            <summary>
            The type the factory instantiates
            </summary>
        </member>
        <member name="P:TinyIoC.TinyIoCContainer.ObjectFactoryBase.Constructor">
            <summary>
            Constructor to use, if specified
            </summary>
        </member>
        <member name="M:TinyIoC.TinyIoCContainer.ObjectFactoryBase.GetObject(System.Type,TinyIoC.TinyIoCContainer,TinyIoC.NamedParameterOverloads,TinyIoC.ResolveOptions)">
            <summary>
            Create the type
            </summary>
            <param name="requestedType">Type user requested to be resolved</param>
            <param name="container">Container that requested the creation</param>
            <param name="parameters">Any user parameters passed</param>
            <param name="options"></param>
            <returns></returns>
        </member>
        <member name="T:TinyIoC.TinyIoCContainer.MultiInstanceFactory">
            <summary>
            IObjectFactory that creates new instances of types for each resolution
            </summary>
        </member>
        <member name="T:TinyIoC.TinyIoCContainer.DelegateFactory">
            <summary>
            IObjectFactory that invokes a specified delegate to construct the object
            </summary>
        </member>
        <member name="T:TinyIoC.TinyIoCContainer.WeakDelegateFactory">
            <summary>
            IObjectFactory that invokes a specified delegate to construct the object
            Holds the delegate using a weak reference
            </summary>
        </member>
        <member name="T:TinyIoC.TinyIoCContainer.InstanceFactory">
            <summary>
            Stores an particular instance to return for a type
            </summary>
        </member>
        <member name="T:TinyIoC.TinyIoCContainer.WeakInstanceFactory">
            <summary>
            Stores an particular instance to return for a type
            
            Stores the instance with a weak reference
            </summary>
        </member>
        <member name="T:TinyIoC.TinyIoCContainer.SingletonFactory">
            <summary>
            A factory that lazy instantiates a type and always returns the same instance
            </summary>
        </member>
        <member name="T:TinyIoC.TinyIoCContainer.DelegateSingletonFactory">
            <summary>
            A factory that lazy instantiates a type using a factory method and after construction
            always returns the same instance
            </summary>
        </member>
        <member name="T:TinyIoC.TinyIoCContainer.CustomObjectLifetimeFactory">
            <summary>
            A factory that offloads lifetime to an external lifetime provider
            </summary>
        </member>
        <member name="P:TinyIoC.TinyIoCContainer.Current">
            <summary>
            Lazy created Singleton instance of the container for simple scenarios
            </summary>
        </member>
        <member name="F:MobileApp.Common.Configuration.ConfigurationStore.ConfigFileName">
            <summary>
            This file is in the Assets folder in MobileApp.Android
            </summary>
        </member>
        <member name="F:MobileApp.Common.Configuration.ConfigurationStore.ConfigurationContent">
            <summary>
            Gets set by MobileApp.Android and MobileApp.iOS when the app gets started.
            </summary>
        </member>
        <member name="M:MobileApp.Common.Configuration.ConfigurationStore.SetConfigToStandardValues">
            <summary>
            Used when loading the configuration file failed.
            </summary>
        </member>
        <member name="P:MobileApp.Common.Models.DTOs.ApplicationSettingsDto.AesKey">
            <summary>
            Exchanged to the mobile app securley. Used to decrypt
            the authentication information (in RestAPI) sent by the mobile app.
            </summary>
        </member>
        <member name="P:MobileApp.Common.Models.DTOs.ApplicationSettingsDto.AesIV">
            <summary>
            Exchanged to the mobile app securley. Used to decrypt
            the authentication information (in RestAPI) sent by the mobile app.
            </summary>
        </member>
        <member name="P:MobileApp.Common.Models.DTOs.ApplicationSettingsDto.BasestationCert">
            <summary>
            Certificate of the basestation
            </summary>
        </member>
        <member name="P:MobileApp.Common.Models.DTOs.ModuleInfoDto.InformationTimestamp">
            <summary>
            Time when the information got requested from the server
            </summary>
        </member>
        <member name="P:MobileApp.Common.Models.Entities.ApplicationSettings.AesKey">
            <summary>
            Exchanged to the mobile app securley. Used to decrypt
            the authentication information (in RestAPI) sent by the mobile app.
            </summary>
        </member>
        <member name="P:MobileApp.Common.Models.Entities.ApplicationSettings.AesIV">
            <summary>
            Exchanged to the mobile app securley. Used to decrypt
            the authentication information (in RestAPI) sent by the mobile app.
            </summary>
        </member>
        <member name="P:MobileApp.Common.Models.Entities.ApplicationSettings.BasestationCert">
            <summary>
            Certificate of the basestation
            </summary>
        </member>
        <member name="P:MobileApp.Common.Models.Entities.Configuration.ConnectionSettings.CommandsListener_Port">
            <summary>
            Port on which the command service is listening on the basestation
            </summary>
        </member>
        <member name="P:MobileApp.Common.Models.Entities.ModuleInfo.InformationTimestamp">
            <summary>
            Time when the information got requested from the server
            </summary>
        </member>
        <member name="P:MobileApp.Common.Specifications.Configuration.IConnectionSettings.CommandsListener_Port">
            <summary>
            Port on which the command service is listening on the basestation
            </summary>
        </member>
        <member name="T:MobileApp.Common.Specifications.Cryptography.IAesEncrypterDecrypter">
            <summary>
            Class to encrypt and decrypt byte arrays with RijndaelManaged.
            </summary>
        </member>
        <member name="M:MobileApp.Common.Specifications.Cryptography.IAesEncrypterDecrypter.Encrypt(System.String)">
            <summary>
            Encrypts a string with the Aes key, stored in the application settings.
            </summary>
            <param name="data">Data to encrypt.</param>
            <returns>Encrypted data.</returns>
        </member>
        <member name="M:MobileApp.Common.Specifications.Cryptography.IAesEncrypterDecrypter.Encrypt(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Encryptes data with given key and iv.
            </summary>
            <param name="data">Data to encrypt.</param>
            <param name="iv">Aes initialization vector.</param>
            <param name="key">Aes key.</param>
            <returns>Encrypted data.</returns>
            <exception cref="T:System.Exception">Thrown if something went wrong.</exception>
        </member>
        <member name="M:MobileApp.Common.Specifications.Cryptography.IAesEncrypterDecrypter.Decrypt(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Decrypts data with given key and iv.
            </summary>
            <param name="data">Data to decrypt.</param>
            <param name="iv">Aes initialization vector.</param>
            <param name="key">Aes key.</param>
            <returns>Decrypted data.</returns>
            <exception cref="T:System.Exception">Thrown if something went wrong.</exception>
        </member>
        <member name="M:MobileApp.Common.Specifications.DataAccess.Communication.IApiRequestsRelayServer.Start(MobileApp.Common.Specifications.DataAccess.Communication.IEncryptedTunnel,System.Threading.CancellationToken)">
            <summary>
            Starts a local server that listens on the same port as the basestation API
            </summary>
            <param name="relayTunnel">Tunnel to relay the received packages to.</param>
            <param name="cancellationToken">To stop the server.</param>
            <returns></returns>
        </member>
        <member name="M:MobileApp.Common.Specifications.DataAccess.Communication.ICommandsRelayServer.Start(MobileApp.Common.Specifications.DataAccess.Communication.IEncryptedTunnel,System.Threading.CancellationToken)">
            <summary>
            Starts a local server that listens on the same port as the basestation command service.
            </summary>
            <param name="relayTunnel">Tunnel to relay the received packages to.</param>
            <param name="cancellationToken">To stop the server.</param>
            <returns></returns>
        </member>
        <member name="M:MobileApp.Common.Specifications.DataAccess.Communication.IEncryptedTunnel.SendAndReceiveData(System.Byte[],System.Threading.CancellationToken)">
            <summary>
            Calls first SendData() and then ReceiveData().
            For multithreading (locking) purposes.
            </summary>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="T:MobileApp.Common.Specifications.DataObjects.IServiceDetails">
            <summary>
            Used in WanPackages, when the user accesses this server via peer to peer or via the external server.
            </summary>
        </member>
        <member name="P:MobileApp.Common.Specifications.DataObjects.IServiceDetails.HoldConnectionOpen">
            <summary>
            True, to hold the connection from the LocalRelayManager in the Project GardeningSystem to the specified Service (ServiceType, Port) in Gardeningsystem open
            </summary>
        </member>
        <member name="T:MobileApp.Common.Specifications.DataObjects.IServicePackage">
            <summary>
            Contains information of what currently active connection should be used in LocalRelayManager in the project "GardeningSystem" to forward data.
            </summary>
        </member>
        <member name="M:MobileApp.Common.Specifications.ILoggerService.AddEventHandler(System.EventHandler)">
            <summary>
            The <paramref name="eventHandler"/> will get invoked when a new entry gets written to the log file.
            </summary>
            <param name="eventHandler"></param>
        </member>
        <member name="P:MobileApp.Common.Specifications.IValvesListViewModel.LinkedValves">
            <summary>
            List of valves which gets displayed in an view model
            </summary>
        </member>
        <member name="M:MobileApp.Common.Specifications.Managers.IAPIManager.Login(System.String,System.String)">
            <summary>
            Performs a login and stores a Json Web Token (JwT) in the SettingsManager. 
            This token will be used by all following api requests/posts.
            </summary>
            <param name="email"></param>
            <param name="password"></param>
            <returns>True when login was successfully</returns>
        </member>
        <member name="M:MobileApp.Common.Specifications.Managers.IAPIManager.ChangeLoginInfo(MobileApp.Common.Models.DTOs.UpdateUserDto)">
            <summary>
            Registers a new user.
            Does not request an token. Login must be called in order to being able to access fully the api.
            </summary>
            <param name="email"></param>
            <param name="password"></param>
            <returns>True when the registration was successful.</returns>
        </member>
        <member name="M:MobileApp.Common.Specifications.Managers.IAPIManager.Logout">
            <summary>
            Clears stored session information 
            </summary>
        </member>
        <member name="M:MobileApp.Common.Specifications.Managers.IAPIManager.GetModules">
            <summary>
            Requests all modules from rest api.
            </summary>
            <returns>Null when error</returns>
            <exception cref="T:System.UnauthorizedAccessException">Gets thrown when token is not valid.</exception>
        </member>
        <member name="M:MobileApp.Common.Specifications.Managers.IAPIManager.UpdateModule(MobileApp.Common.Models.Entities.ModuleInfo)">
            <exception cref="T:System.UnauthorizedAccessException">Gets thrown when token is not valid.</exception>
        </member>
        <member name="M:MobileApp.Common.Specifications.Managers.IAPIManager.AddModule(MobileApp.Common.Models.Entities.ModuleInfo)">
            <exception cref="T:System.UnauthorizedAccessException">Gets thrown when token is not valid.</exception>
        </member>
        <member name="M:MobileApp.Common.Specifications.Managers.IAPIManager.DeleteModule(System.Byte)">
            <exception cref="T:System.UnauthorizedAccessException">Gets thrown when token is not valid.</exception>
        </member>
        <member name="M:MobileApp.Common.Specifications.Managers.IAPIManager.IsBasestationConnectedToWlan">
            <exception cref="T:System.UnauthorizedAccessException">Gets thrown when token is not valid.</exception>
        </member>
        <member name="M:MobileApp.Common.Specifications.Managers.IBasestationFinderManager.FindLocalBaseStation">
            <summary>
            Trys to find a basestation via a multicast ip address.
            Retries a view times if no basestation answered.
            Stores the ip address of a found basestation in settings.
            </summary>
            <returns>True when a basestation got found. Otherwise false.</returns>
        </member>
        <member name="M:MobileApp.Common.Specifications.Managers.ICommandManager.ConnectToWlan(MobileApp.Common.Models.DTOs.WlanInfoDto)">
            <param name="wlanInfo">wlan login data</param>
            <returns>If the operation was successfull</returns>
        </member>
        <member name="M:MobileApp.Common.Specifications.Managers.IRelayManager.ConnectToTheBasestation(System.Threading.CancellationToken,System.Boolean,System.Boolean)">
            <summary>
            Tells the external server to connect it to the basestation.
            Changes the endpoints of all clients to a local relay server, if the connection with the basestation was successful.
            </summary>
            <param name="cancellationToken">To close all open connections and stop relaying api requests or commands.</param>
            <param name="forceRelay">True, to redirect all traffic over the external server and not directly to the basestation.</param>
            <param name="test">True when the the connection is only for a relay test.</param>
            <returns>True, when a connection got esablished.</returns>
        </member>
        <member name="M:MobileApp.Common.Specifications.Managers.ISettingsManager.UpdateCurrentSettings(System.Func{MobileApp.Common.Models.DTOs.ApplicationSettingsDto,MobileApp.Common.Models.DTOs.ApplicationSettingsDto})">
            <summary>
            Ensures that up to date settings get passed to updateFunc and
            multiple threads can not change settings while calling this function.
            </summary>
            <param name="updateFunc">gets current settings and must return the changed settings</param>
        </member>
        <member name="M:MobileApp.Common.Specifications.Services.ICachePageDataService.RemoveFromStore(System.Guid)">
            <summary>
            Returns and removes an object form storage.
            </summary>
            <param name="storageId"></param>
            <returns>Returns the stored object</returns>
        </member>
        <member name="M:MobileApp.Common.Specifications.Services.ICachePageDataService.UpdateCachedPageData(System.Guid,System.Func{System.Object,System.Object})">
            <summary>
            Updates a already stored object.
            </summary>
            <param name="storageId">Id of the object that should get updated.</param>
            <param name="updateFunc">Takes the current object stored at <paramref>storageId</paramref> and returns the updated object.</param>
            <exception cref="T:System.ArgumentException">When there is no object stored at the passed <paramref>storageId</paramref>.</exception>
        </member>
        <member name="M:MobileApp.Common.Specifications.Services.ICachePageDataService.GetFromStore(System.Guid)">
            <param name="storageId"></param>
            <returns>An object stored under <paramref>storageId</paramref>.</returns>
            <exception cref="T:System.ArgumentException">When there is no object stored at the passed <paramref>storageId</paramref>.</exception>
        </member>
        <member name="M:MobileApp.Common.Utilities.IpUtils.IPEndPoint_TryParse(System.String)">
            <summary>
            Handles IPv4 and IPv6 notation.
            </summary>
            <param name="endPoint"></param>
            <returns>Null when parsing failed.</returns>
        </member>
    </members>
</doc>
